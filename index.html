<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MK8 Results OCR — vanilla JS starter</title>
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; font: 14px/1.4 system-ui, sans-serif; background:#0a0a0a; color:#e5e5e5; }
    header, main { max-width: 1100px; margin: 0 auto; padding: 16px; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap: wrap; }
    select, button { background:#111; color:#e5e5e5; border:1px solid #333; border-radius:12px; padding:8px 12px; }
    button[disabled] { opacity: .6; }
    .panel { background:#0f0f0f; border:1px solid #222; border-radius:16px; padding:12px; }
    video { width:100%; border-radius:12px; background:#000; }
    ol.results { list-style: none; padding:0; margin:0; display:grid; gap:6px; }
    ol.results li { display:flex; gap:8px; align-items:center; background:#141414; border:1px solid #242424; border-radius:12px; padding:8px 10px; }
    .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .muted { color:#9aa0a6; }
    /* Buttons: semantic variants */
    .btn--primary { background:#0f3a15; border-color:#1f5e2a; color:#eaffea; }
    .btn--primary:hover { filter: brightness(1.12); }
    .btn--danger { background:#3b0a0a; border-color:#5a1a1a; color:#ffd7d7; }
    .btn--danger:hover { filter: brightness(1.12); }
    /* Utility */
    .push-left { margin-right:auto; }
    /* Scoreboard controls spacing (above the Export button row) */
    .score-actions { margin-top: 12px; }
    /* Scoreboard */
    table.score th, table.score td { border:1px solid #242424; padding:6px 8px; text-align:center; }
    table.score th:first-child, table.score td:first-child { text-align:left; }
    table.score thead th { background:#141414; position:sticky; top:0; }
    .gallery a { display:block; background:#141414; border:1px solid #242424; border-radius:12px; overflow:hidden; text-decoration:none; color:inherit; }
    .gallery img { width:100%; display:block; }
    .gallery .cap { padding:6px 8px; font-size:12px; color:#9aa0a6; }
    /* Modal */
    dialog { border:none; border-radius:16px; padding:0; background:#101010; color:#e5e5e5; }
    dialog::backdrop { background: rgba(0,0,0,.6); }
    .modal { padding:16px; min-width: 520px; }
    .grid { display:grid; gap:8px; grid-template-columns: 80px 1fr 200px; align-items:center; }
    .modal footer { display:flex; justify-content:flex-end; gap:8px; margin-top:12px; }
    .badge { background:#1f2937; padding:2px 8px; border-radius:999px; font-size:12px; }
    textarea { width:100%; min-height:150px; box-sizing:border-box; background:#0b0b0b; color:#e5e5e5; border:1px solid #222; border-radius:8px; padding:8px; resize:vertical }
  </style>
</head>
<body>
  <header class="row" style="justify-content: space-between">
    <h1 style="font-size: 18px; font-weight: 600; margin:0">MKW Results tracker</h1>
    <div class="row">
      <label class="muted">Camera</label>
      <select id="camera"></select>
      <button id="capture" class="btn--primary">📸 Capture & OCR</button>
    </div>
  </header>

  <main class="row">
    <section class="panel" style="flex:1 1 560px; min-width: 360px;">
      <video id="preview" autoplay playsinline muted></video>
    </section>
    <section class="panel" style="flex:1 1 420px; min-width: 320px;">
      <h2 style="margin:0 0 8px 0; font-size:16px">Last capture</h2>
      <ol id="output" class="results"></ol>
    </section>
  </main>

  <!-- Scoreboard -->
  <section class="panel" style="max-width:1100px; margin:16px auto;">
    <h2 style="margin:0 0 8px 0; font-size:16px">Scoreboard</h2>
    <div style="overflow:auto;">
      <table id="scoreTable" class="score mono" style="width:100%; border-collapse:collapse;"></table>
    </div>
    <div class="row score-actions">
      <button id="exportScores" class="btn--primary">Export scores</button>
    </div>
  </section>

  <!-- Race history (snapshots) -->
  <section class="panel" style="max-width:1100px; margin:16px auto;">
    <h2 style="margin:0 0 8px 0; font-size:16px">Race history</h2>
    <div id="raceGallery" class="gallery" style="display:grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap:10px;"></div>
  </section>

  <!-- Roster input modal -->
  <dialog id="rosterDialog" closedby="none">
    <form method="dialog" class="modal">
      <h3 style="margin:0 0 12px 0; font-size:16px">Paste player roster</h3>
      <p class="muted" style="margin:0 0 8px 0">Paste 12 lines like: <code>1. Adam (12345 MMR)</code></p>
      <textarea id="rosterInput" rows="12"></textarea>
      <footer>
        <button id="rosterConfirm" type="button" class="btn--primary">Use roster</button>
      </footer>
    </form>
  </dialog>

  <!-- Manual resolve modal -->
  <dialog id="resolveDialog">
    <form method="dialog" class="modal">
      <h3 style="margin:0 0 12px 0; font-size:16px">Resolve unmatched players</h3>
      <div id="resolveGrid" class="grid"></div>
      <footer>
        <button value="cancel">Cancel</button>
        <button id="resolveConfirm" type="button" class="btn--primary">Confirm</button>
      </footer>
    </form>
  </dialog>

  <!-- Edit race modal -->
  <dialog id="editRaceDialog">
    <form method="dialog" class="modal">
      <h3 style="margin:0 0 12px 0; font-size:16px">Edit race</h3>
      <div class="grid" id="editRaceGrid" style="grid-template-columns: 1fr 160px;"></div>
      <footer>
        <button id="raceDelete" type="button" class="btn--danger push-left">Delete race</button>
        <button value="cancel">Cancel</button>
        <button id="raceSave" type="button" class="btn--primary">Save</button>
      </footer>
    </form>
  </dialog>

  <!-- Export scores modal -->
  <dialog id="exportDialog">
    <form method="dialog" class="modal">
      <h3 style="margin:0 0 12px 0; font-size:16px">Export scores</h3>
      <textarea id="exportText" rows="12" readonly></textarea>
      <footer>
        <button value="cancel">Close</button>
        <button id="exportCopy" type="button" class="btn--primary">Copy</button>
      </footer>
    </form>
  </dialog>

  <script type="module">// @ts-check
  /**
   * Import Tesseract without a build step.
   */
  import Tesseract from 'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.esm.min.js';

  /**
   * @typedef {{ id:string, name:string, seed?:number, mmr?:number, ign?:string }} Player
   * @typedef {{ placement:number, playerId:(string|null), resolvedName:string, ocrText:string, ocrConfidence:number, dc:boolean }} Placement
   * @typedef {{ id:number, timestamp:number, placements:Placement[], snapshotUrl:string }} Race
   * @typedef {{ canvasWidth:number, canvasHeight:number, nameRects:Array<{x:number,y:number,w:number,h:number}> }} OCRGrid
   * @typedef {{ whitelist?:string, lang?:string, psm?:number, maxEditDistance?:number }} ProcessOptions
   */

  /**
   * @template {Element} T
   * @param {string} sel
   * @param {ParentNode} [root=document]
   * @returns {T|null}
   */
  const $ = (sel, root = document) =>
    /** @type {T|null} */ (root.querySelector(sel));

  /**
   * @template {Element} T
   * @param {string} sel
   * @param {ParentNode} [root=document]
   * @returns {T[]}
   */
  const $$ = (sel, root = document) =>
    /** @type {T[]} */ (Array.from(root.querySelectorAll(sel)));

  const video = /** @type {HTMLVideoElement} */($('#preview'));
  const cameraSelect = /** @type {HTMLSelectElement} */($('#camera'));
  const captureBtn = /** @type {HTMLButtonElement} */($('#capture'));
  const outputOl = /** @type {HTMLOListElement} */($('#output'));

  const rosterDlg = /** @type {HTMLDialogElement} */($('#rosterDialog'));
  const rosterInput = /** @type {HTMLTextAreaElement} */($('#rosterInput'));
  const rosterConfirm = /** @type {HTMLButtonElement} */($('#rosterConfirm'));

  const scoreTable = /** @type {HTMLTableElement} */($('#scoreTable'));
  const raceGallery = /** @type {HTMLDivElement} */($('#raceGallery'));
  const exportBtn = /** @type {HTMLButtonElement} */($('#exportScores'));

  const editDlg   = /** @type {HTMLDialogElement} */($('#editRaceDialog'));
  const editGrid  = /** @type {HTMLDivElement} */($('#editRaceGrid'));
  const raceSave  = /** @type {HTMLButtonElement} */($('#raceSave'));
  const raceDel   = /** @type {HTMLButtonElement} */($('#raceDelete'));

  const exportDlg  = /** @type {HTMLDialogElement} */($('#exportDialog'));
  const exportText = /** @type {HTMLTextAreaElement} */($('#exportText'));
  const exportCopy = /** @type {HTMLButtonElement} */($('#exportCopy'));

  /** @type {Player[]} */
  let roster = [];

  /** @type {Race[]} */
  const races = [];

  // 1st..12th points
  const POINTS_BY_PLACEMENT = [15,12,10,9,8,7,6,5,4,3,2,1];

  /**
   * Parse lines like: "1. Adam (12345 MMR)"
   * @param {string} text
   * @returns {Player[]}
   */
  function parseRoster(text){
    const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
    if(lines.length !== 12) throw new Error(`Expected 12 lines, got ${lines.length}`);
    /** @type {Player[]} */ const out = [];
    const re = /^\s*(\d+)\.\s+(.*?)\s+\((\d+)\s*MMR\)\s*$/i;
    for (const line of lines){
      const m = re.exec(line);
      if(!m) throw new Error(`Bad line: "${line}"`);
      const seed = Number(m[1]);
      const name = m[2];
      const mmr  = Number(m[3]);
      out.push({ id: `seed-${seed}`, name, seed, mmr });
    }
    return out;
  }

  /** @param {Player[]} r */
  function formatRoster(r){
    return r.map(p => `${p.seed ?? Number((p.id||'').replace('seed-','')||0)}. ${p.name} (${p.mmr ?? 0} MMR)`).join('\n');
  }

  // Roster dialog wiring
  rosterConfirm.addEventListener('click', (ev) => {
    ev.preventDefault();
    try {
      roster = parseRoster(rosterInput.value);
      rosterDlg.close();
    } catch (e) {
      alert(String(/** @type {any} */(e).message || e));
    }
  });

  // === Calibration ===
  /** @type {OCRGrid} */
  const grid = {
    canvasWidth: 1920,
    canvasHeight: 1080,
    nameRects: generateRowRects({ count: 12, startY: 40, rowHeight: 77, x: 1270, w: 340 }),
  };

  /**
   * Build row rectangles from simple parameters
   * @param {{count:number,startY:number,rowHeight:number,x:number,w:number}} p
   */
  function generateRowRects(p) {
    const rects = [];
    for (let i=0;i<p.count;i++) rects.push({ x:p.x, y:Math.round(p.startY+i*p.rowHeight), w:p.w, h:p.rowHeight });
    return rects;
  }

  /**
   * @param {HTMLCanvasElement} el
   * @param {CanvasRenderingContext2DSettings} [options]
   * @returns {CanvasRenderingContext2D}
   */
  function ctx2d(el, options={}) {
    const ctx = el.getContext('2d', options);
    if(!ctx) throw new Error('2D context unavailable');
    return ctx;
  }

  // === Fuzzy matching helpers ===
  function normalizeName(s) {
    return s.normalize('NFKD')
      .replace(/[\u0300-\u036f]/g,'')
      .replace(/[^A-Za-z0-9 _\-\[\]\|\.]/g,'')
      .replace(/\s+/g,' ')
      .trim()
      .toLowerCase();
  }
  function levenshtein(a,b){ if(a===b) return 0; if(!a.length) return b.length; if(!b.length) return a.length; const v0=new Array(b.length+1).fill(0); const v1=new Array(b.length+1).fill(0); for(let i=0;i<=b.length;i++) v0[i]=i; for(let i=0;i<a.length;i++){ v1[0]=i+1; const ca=a.charCodeAt(i); for(let j=0;j<b.length;j++){ const cost= ca===b.charCodeAt(j) ? 0 : 1; v1[j+1]=Math.min(v1[j]+1, v0[j+1]+1, v0[j]+cost);} for(let j=0;j<=b.length;j++) v0[j]=v1[j]; } return v1[b.length]; }

  /**
   * Popcount for 32-bit masks.
   * @param {number} x
   */
  function popcount(x){ let c=0; for(; x; x &= x-1) c++; return c; }

  /**
   * Solve the assignment (player i -> row j) minimizing total integer costs.
   * @param {number[][]} cost - NxN matrix where cost[i][j] is the cost to map player i to row j
   * @returns {number[]} assignment array A of length N where A[i] = j (row index for player i)
   */
  function solveAssignmentDP(cost){
    const n = cost.length, SIZE = 1 << n;
    /** @type {number[]} */ const dp = new Array(SIZE).fill(Infinity);
    /** @type {number[]} */ const parent = new Array(SIZE).fill(-1);
    /** @type {number[]} */ const choice = new Array(SIZE).fill(-1);
    dp[0] = 0;

    for (let mask = 0; mask < SIZE; mask++){
      const i = popcount(mask);                 // next player index
      if (i >= n) continue;
      const base = dp[mask];
      for (let j = 0; j < n; j++){
        if (mask & (1 << j)) continue;          // row j already used
        const m2 = mask | (1 << j);
        const val = base + cost[i][j];
        if (val < dp[m2]) { dp[m2] = val; parent[m2] = mask; choice[m2] = j; }
      }
    }

    // reconstruct
    const assign = new Array(n).fill(-1);
    let mask = SIZE - 1;
    for (let i = n - 1; i >= 0; i--){
      const j = choice[mask];
      assign[i] = j;
      mask = parent[mask];
    }
    return assign;
  }

  /**
  * Lock in-game names (IGNs) from a fully-resolved, full (12) race.
  * Stores pretty (raw OCR) in p.ign; compares using normalizeName(p.ign).
  * @param {Placement[]} placements
  * @param {Player[]} roster
  */
  function lockIGNsFromPlacements(placements, roster){
    // require: 12 rows, all resolved, and no blanks
    if (placements.length !== 12) return;
    if (placements.some(p => !p.playerId)) return;
    if (placements.some(p => !normalizeName(p.ocrText))) return;

    // Build a set to avoid duplicate IGNs across players (shouldn't happen)
    const usedNorm = new Set(roster.map(p => p.ign ? normalizeName(p.ign) : null).filter(Boolean));

    for (const row of placements){
      const ply = roster.find(r => r.id === row.playerId);
      if (!ply) continue;
      const raw = row.ocrText.trim();
      const norm = normalizeName(raw);
      if (!norm) continue;
      // If the player already has an ign, keep the first one
      if (ply.ign && normalizeName(ply.ign) === norm) continue;
      if (ply.ign) continue; // don't override
      // avoid accidental duplicates
      if (usedNorm.has(norm)) continue;
      ply.ign = raw;
      usedNorm.add(norm);
    }
  }

  let _worker = /** @type {any} */(null);
  async function getWorker(lang='eng'){
    if(_worker) return _worker;
    _worker = await Tesseract.createWorker(lang, 1, { logger: ()=>{} });
    return _worker;
  }

  /**
   * Capture a single frame from a video element into a canvas of known size.
   * @param {HTMLVideoElement} videoEl
   * @param {number} w
   * @param {number} h
   */
  function captureFrame(videoEl, w, h){
    const canvas = document.createElement('canvas');
    canvas.width = w; canvas.height = h;
    const ctx = ctx2d(canvas, { willReadFrequently:true });
    const vidW = videoEl.videoWidth, vidH = videoEl.videoHeight;
    if(!vidW || !vidH) return canvas; // video not loaded, return empty frame
    const scale = Math.min(vidW / w, vidH / h);
    const sx = Math.floor((vidW - w*scale)/2), sy = Math.floor((vidH - h*scale)/2);
    const sW = Math.floor(w*scale), sH = Math.floor(h*scale);
    ctx.drawImage(videoEl, sx, sy, sW, sH, 0, 0, w, h);
    return canvas;
  }

  /**
   * Lightweight pre-processing (scale 2x, grayscale + threshold).
   * @param {HTMLCanvasElement} src
   * @param {{x:number,y:number,w:number,h:number}} r
   */
  function preprocessCrop(src, r){
    const innerPad = 15; // crop 15px from top/bottom inside the row box
    const sy = r.y + innerPad;
    const sh = Math.max(1, r.h - innerPad*2);

    const crop = document.createElement('canvas');
    crop.width = r.w; crop.height = sh;
    const cctx = ctx2d(crop, { willReadFrequently:true });
    cctx.drawImage(src, r.x, sy, r.w, sh, 0, 0, r.w, sh);

    const scale = 2;
    const pre = document.createElement('canvas');
    pre.width = r.w*scale; pre.height = sh*scale;
    const pctx = ctx2d(pre, { willReadFrequently:true });
    pctx.imageSmoothingEnabled = false;
    pctx.drawImage(crop, 0, 0, pre.width, pre.height);

    const img = pctx.getImageData(0, 0, pre.width, pre.height);
    const thr = 240; // your calibrated value
    for (let i=0; i<img.data.length; i+=4) {
      const r0 = img.data[i], g0 = img.data[i+1], b0 = img.data[i+2];
      const y0 = (r0*299 + g0*587 + b0*114) / 1000;
      const v = y0 > thr ? 255 : 0;
      img.data[i] = img.data[i+1] = img.data[i+2] = v;
    }
    pctx.putImageData(img, 0, 0);
    return pre;
  }

  /**
   * Turn a pre-captured canvas into a Blob URL.
   * @param {HTMLCanvasElement} base
   * @returns {Promise<string>}
   */
  function snapshotBlobUrlFromCanvas(base) {
    return new Promise((resolve, reject) => {
      base.toBlob(b => {
        if (!b) return reject(new Error('toBlob failed'));
        resolve(URL.createObjectURL(b));
      }, 'image/png');
    });
  }

  /**
   * Compute points for a single race.
   * - Blank OCR (row.ocrText empty after normalize) always scores 1.
   * - Otherwise use placement mapping (1..12 -> POINTS_BY_PLACEMENT).
   * @param {Placement[]} placements
   * @returns {Record<string, number>} map playerId -> points for this race
   */
  function computeRacePoints(placements){
    /** @type {Record<string, number>} */
    const points = {};
    for (const row of placements) {
      if (!row.playerId) continue; // unresolved rows won't contribute (shouldn't happen post-manual)
      const blank = row.dc === true || !normalizeName(row.ocrText);
      const p = blank ? 1 : POINTS_BY_PLACEMENT[Math.min(11, Math.max(0, row.placement - 1))];
      points[row.playerId] = (points[row.playerId] || 0) + p;
    }
    return points;
  }

  /**
   * Build totals across all races.
   * @returns {Record<string, number>}
   */
  function computeTotals(){
    /** @type {Record<string, number>} */ const totals = {};
    for (const r of races) {
      const pts = computeRacePoints(r.placements);
      for (const [pid, v] of Object.entries(pts)) {
        totals[pid] = (totals[pid] || 0) + v;
      }
    }
    return totals;
  }

  /**
   * Build lounge-bot export text: `${name} ${score}` per line.
   * Uses seed order if available, else name.
   */
  function buildScoreExport(){
    const totals = computeTotals();
    const ordered = [...roster].sort((a,b) => {
      const as = a.seed ?? 9999, bs = b.seed ?? 9999;
      if (as !== bs) return as - bs;
      return a.name.localeCompare(b.name);
    });
    return ordered.map(p => `${p.name} ${totals[p.id] || 0}`).join('\n');
  }

  exportBtn.addEventListener('click', () => {
    exportText.value = buildScoreExport();
    exportDlg.showModal();
    // auto-select for convenience
    setTimeout(() => { exportText.focus(); exportText.select(); }, 0);
  });

  exportCopy.addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(exportText.value);
      const old = exportCopy.textContent;
      exportCopy.textContent = 'Copied!';
      setTimeout(() => exportCopy.textContent = old, 1200);
    } catch {
      // Fallback: focus + select so the user can Cmd/Ctrl+C
      exportText.focus(); exportText.select();
      const old = exportCopy.textContent;
      exportCopy.textContent = 'Press Ctrl/Cmd+C';
      setTimeout(() => exportCopy.textContent = old, 2000);
    }
  });

  /**
   * Open the edit dialog for a race index.
   * Lets you set each player's placement (1..12) or mark DC.
   * @param {number} idx
   */
  function openEditRace(idx){
    const race = races[idx];
    if (!race) return;

    editGrid.innerHTML = '';

    // Build per-player selects. Preselect from current placements.
    for (const p of roster){
      const row = race.placements.find(r => r.playerId === p.id) || null;
      const isDC = row ? (row.dc === true || !normalizeName(row.ocrText)) : true;

      const name = document.createElement('div');
      name.textContent = p.name;

      const sel = document.createElement('select');
      sel.dataset.playerId = p.id;

      // Placements 1..12
      for (let k = 1; k <= 12; k++){
        const opt = document.createElement('option');
        opt.value = String(k);
        const ordinal = ['st','nd','rd'][k-1] || 'th';
        opt.textContent = `${k}${ordinal}`;
        sel.appendChild(opt);
      }

      // DC option
      const oDC = document.createElement('option');
      oDC.value = 'dc';
      oDC.textContent = 'DC';
      sel.appendChild(oDC);

      // Preselect
      sel.value = isDC ? 'dc' : String(row?.placement ?? '');

      editGrid.append(name, sel);
    }

    // Wire buttons (remove old listeners first to avoid stacking)
    raceSave.onclick = null;
    raceDel.onclick = null;

    raceSave.onclick = () => {
      // Collect choices
      /** @type {{pid:string, choice:'dc'|number}[]} */
      const picks = [];
      /** @type {HTMLSelectElement[]} */(Array.from(editGrid.querySelectorAll('select'))).forEach(sel => {
        const pid = sel.dataset.playerId || '';
        const val = sel.value === 'dc' ? 'dc' : Number(sel.value);
        picks.push({ pid, choice: /** @type any */(val) });
      });

      // Validate unique numbered placements
      const nums = picks.filter(x => x.choice !== 'dc').map(x => /** @type {number} */(x.choice));
      const uniq = new Set(nums);
      if (nums.length !== uniq.size) {
        alert('Each placement 1..12 can only be chosen once.');
        return;
      }

      // Rebuild a new placements array for this race:
      // Keep original OCR fields; reset mapping; then assign numbered picks; then fill DCs into remaining slots (bottom-up).
      /** @type {Placement[]} */
      const newRows = race.placements.map(r => ({
        placement: r.placement,
        playerId: null,
        resolvedName: '',
        ocrText: r.ocrText,
        ocrConfidence: r.ocrConfidence,
        dc: false
      }));

      // Assign numbered placements
      for (const pk of picks){
        if (pk.choice === 'dc') continue;
        const row = newRows[pk.choice - 1];
        row.playerId = pk.pid;
        const ply = roster.find(x => x.id === pk.pid);
        row.resolvedName = ply ? ply.name : '';
        row.dc = false;
      }

      // Assign DC players to remaining rows, bottom-up
      const dcPlayers = picks.filter(x => x.choice === 'dc').map(x => x.pid);
      const remainingPlacements = newRows
        .filter(r => !r.playerId)
        .map(r => r.placement)
        .sort((a,b) => b - a); // highest placement numbers first

      for (let i = 0; i < dcPlayers.length; i++){
        const pid = dcPlayers[i];
        const plNum = remainingPlacements[i];
        if (plNum == null) break; // shouldn't happen
        const row = newRows[plNum - 1];
        row.playerId = pid;
        const ply = roster.find(x => x.id === pid);
        row.resolvedName = ply ? ply.name : '';
        row.dc = true; // override as DC (scores 1 and shows —)
      }

      // Replace and refresh UI
      race.placements = newRows;

      // If this was Race 1 and now fully resolved with no blanks/DC, (re)lock IGNs
      if (idx === 0) {
        lockIGNsFromPlacements(race.placements, roster);
      }

      editDlg.close('ok');
      // Re-render
      if (idx === races.length - 1) {
        renderResults(race.placements);
      }
      renderScoreboard();
      renderRaceGallery();
    };

    raceDel.onclick = () => {
      if (!confirm('Delete this race permanently?')) return;
      try { URL.revokeObjectURL(race.snapshotUrl); } catch {}
      races.splice(idx, 1);
      editDlg.close('ok');
      // Re-render
      renderScoreboard();
      renderRaceGallery();
      // Update "Last capture" view to the new last race (if any)
      const last = races[races.length - 1];
      outputOl.innerHTML = '';
      if (last) renderResults(last.placements);
    };

    editDlg.showModal();
  }

  /**
   * Core API — kicks off capture, OCR, fuzzy match, optional manual resolve, then resolves placements.
   * Matches your desired call shape: await processResultsScreen()
   * @param {HTMLCanvasElement} canvas
   * @param {Player[]} roster
   * @param {OCRGrid} grid
   * @param {ProcessOptions} [options]
   * @returns {Promise<Placement[]>}
   */
  async function processResultsScreen(canvas, roster, grid, options = {}) {
    const { canvasWidth, canvasHeight, nameRects } = grid;
    const {
      whitelist = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 -_[]|.',
      lang = 'eng',
      psm = 7, // SINGLE_LINE
      maxEditDistance = 3,
    } = options;

    const worker = await getWorker(lang);
    await worker.setParameters({
      tessedit_char_whitelist: whitelist,
      preserve_interword_spaces: '1', user_defined_dpi: '300',
      load_system_dawg: 'F', load_freq_dawg: 'F', textord_heavy_nr: '1',
      tessedit_pageseg_mode: String(psm)
    });

    /** @type {{ text:string, confidence:number }[]} */
    const rawRows = [];
    for(const rect of nameRects){
      const img = preprocessCrop(canvas, rect);
      const { data } = await worker.recognize(img);
      const best = (data?.text ?? '').replace(/\s+/g,' ').trim();
      const conf = (data && Number.isFinite(data.confidence)) ? data.confidence : 0;
      rawRows.push({ text: best, confidence: conf });
    }

    // Prepare normalized data
    const normRoster = roster.map(p => ({ id:p.id, name:p.name, norm: normalizeName(p.name) }));
    /** @type {Placement[]} */
    const placements = rawRows.map((row, i) => ({
      placement: i + 1,
      playerId: null,
      resolvedName: row.text,
      ocrText: row.text,
      ocrConfidence: row.confidence,
      dc: false
    }));
    const normRows = rawRows.map(r => normalizeName(r.text));

    // Build an integer cost matrix: players (rows) × OCR rows (cols)
    const N = normRoster.length; // expect 12
    const isBlankCol = normRows.map(s => !s);

    // Use IGN if available, else roster name, for each player
    const targetNorm = roster.map(p => normalizeName(p.ign ?? p.name));

    // Map known IGNs -> owner index (for strong preference)
    const ignOwner = Object.create(null);
    for (let i = 0; i < N; i++){
      if (roster[i].ign) {
        ignOwner[normalizeName(roster[i].ign)] = i;
      }
    }

    /** @type {number[][]} */
    const cost = Array.from({ length: N }, () => Array(N).fill(0));

    let maxNonBlankCost = 0;
    // Pass 1: fill non-blank base costs and track the maximum seen
    for (let i = 0; i < N; i++){
      for (let j = 0; j < N; j++){
        if (isBlankCol[j]) continue;
        const d = levenshtein(targetNorm[i], normRows[j]);
        cost[i][j] = d;
        if (d > maxNonBlankCost) maxNonBlankCost = d;
      }
    }

    // Choose penalties
    const BLANK_COST = maxNonBlankCost + 2;        // blanks are strictly worse than any non-blank match
    const IGN_MISMATCH_PENALTY = maxNonBlankCost + 50; // big stick for stealing someone else's IGN

    // Pass 2: assign blank costs
    for (let i = 0; i < N; i++){
      for (let j = 0; j < N; j++){
        if (isBlankCol[j]) cost[i][j] = BLANK_COST;
      }
    }

    // Pass 3: if a row exactly matches a known IGN, heavily penalize assigning it to anyone else.
    // (Optionally treat <=1 edit away as “match” to be robust to tiny OCR noise.)
    for (let j = 0; j < N; j++){
      if (isBlankCol[j]) continue;
      const owner = ignOwner[normRows[j]];
      if (owner == null) continue;
      for (let i = 0; i < N; i++){
        if (i === owner) continue;
        cost[i][j] += IGN_MISMATCH_PENALTY;
      }
    }

    // Solve globally: which OCR row should each player map to?
    const assign = solveAssignmentDP(cost);

    // Apply assignment (invert to fill per-row placements) and record distances
    /** @type {number[]} */ const assignedDist = new Array(N).fill(0);
    for (let i = 0; i < N; i++){
      const j = assign[i];
      placements[j].playerId = normRoster[i].id;
      placements[j].resolvedName = normRoster[i].name;
      assignedDist[j] = cost[i][j];
    }

    // Ambiguity handling:
    //  - If a row has *non-blank* OCR and its assigned distance exceeds maxEditDistance, force manual.
    //  - If there are 2+ blank rows, force manual for those blanks (you prefer human check in 10-player races).
    const blanks = [];
    for (let j = 0; j < N; j++){
      const isBlank = !normRows[j];
      if (!isBlank && assignedDist[j] > maxEditDistance){
        placements[j].playerId = null; // unresolved -> manual
        placements[j].resolvedName = placements[j].ocrText;
      }
      if (isBlank) blanks.push(j);
    }
    if (blanks.length >= 2){
      for (const j of blanks){
        placements[j].playerId = null; // unresolved -> manual for multi-blank case
        // resolvedName can remain as OCR text (blank)
      }
    }

    // If anything is unresolved, open the manual resolver with the remaining players
    if (placements.some(p => !p.playerId)){
      const remaining = normRoster.filter(p => !placements.some(r => r.playerId === p.id));
      const confirmed = await manualResolve(placements, remaining);
      if (!confirmed) {
        const err = new Error('Manual resolve canceled');
        // @ts-ignore add a code for easy identification
        err.code = 'MANUAL_CANCELLED';
        throw err;
      }
    }

    return placements;
  }

  // --- Manual resolve modal ---
  /**
   * @param {Placement[]} placements
   * @param {{id:string,name:string}[]} remaining
   * @returns {Promise<boolean>} true = confirmed/applied, false = canceled
   */
  function manualResolve(placements, remaining){
    const dlg = /** @type {HTMLDialogElement} */($('#resolveDialog'));
    const grid = /** @type {HTMLDivElement} */($('#resolveGrid'));
    grid.innerHTML = '';

    const unresolved = placements.filter(p=>!p.playerId);

    for (const row of unresolved){
      const y1 = document.createElement('div'); y1.className='mono muted'; y1.textContent = `${row.placement}.`;
      const y2 = document.createElement('div'); y2.textContent = 'OCR: ';
      const chip = document.createElement('span'); chip.className = 'badge';
      chip.textContent = `${row.ocrText || '(blank)'} · ${Math.round(row.ocrConfidence)}%`;
      y2.appendChild(chip);
      const y3 = document.createElement('div');
      const sel = document.createElement('select'); sel.dataset.placement = String(row.placement);
      const empty = document.createElement('option'); empty.value=''; empty.textContent='— Select player —'; sel.appendChild(empty);
      for (const p of remaining){ const opt=document.createElement('option'); opt.value=p.id; opt.textContent=p.name; sel.appendChild(opt); }
      y3.appendChild(sel);
      grid.append(y1,y2,y3);
    }

    return new Promise((resolve)=>{
      dlg.showModal();

      const confirmBtn = /** @type {HTMLButtonElement} */($('#resolveConfirm', dlg));

      const onClick = (ev) => {
        ev.preventDefault();
        const selects = /** @type {HTMLSelectElement[]} */($$('select', grid));
        const chosen = selects.map(s=>s.value).filter(Boolean);

        // Require all unresolved rows to be chosen and choices to be unique
        if (chosen.length !== selects.length) return;
        if (new Set(chosen).size !== chosen.length) return;

        // Apply mappings
        for (const s of selects){
          const placement = Number(s.dataset.placement);
          const row = placements.find(p=>p.placement===placement);
          const p = remaining.find(pp=>pp.id===s.value);
          if (row && p){ row.playerId = p.id; row.resolvedName = p.name; }
        }

        dlg.close('ok'); // mark as confirmed
      };

      const onClose = () => {
        confirmBtn.removeEventListener('click', onClick);
        resolve(dlg.returnValue === 'ok'); // true only if we closed with 'ok' above
      };

      confirmBtn.addEventListener('click', onClick);           // <-- no { once:true }
      dlg.addEventListener('close', onClose, { once: true });   // cleanup & resolve
    });
  }

  // --- Minimal page plumbing ---
  async function listCameras(){
    try { const s = await navigator.mediaDevices.getUserMedia({ video:true }); s.getTracks().forEach(t=>t.stop()); } catch {}
    const devices = (await navigator.mediaDevices.enumerateDevices()).filter(d=>d.kind==='videoinput');
    cameraSelect.innerHTML = '';
    if(!devices.length){ const opt=document.createElement('option'); opt.textContent='(no cameras)'; cameraSelect.appendChild(opt); }
    else {
      const opt = document.createElement('option'); opt.value=''; opt.textContent='— Select camera —'; cameraSelect.appendChild(opt);
      for(const d of devices){
        const opt = document.createElement('option'); opt.value=d.deviceId; opt.textContent=d.label || `Camera ${d.deviceId.slice(0,6)}`; cameraSelect.appendChild(opt);
      }
    }
  }

  async function startSelected(){
    const old = /** @type {MediaStream|null} */(video.srcObject);
    if (old) old.getTracks().forEach(t => t.stop());

    if (!cameraSelect.value) { video.srcObject = null; return; }
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video:{ deviceId:{ exact: cameraSelect.value } }, audio:false
      });
      video.srcObject = stream; await video.play();
    } catch (err) {
      console.error(err);
      video.srcObject = null;
      cameraSelect.value = ''; // reset to sentinel
      alert('Could not start the selected camera.');
    }
  }

  captureBtn.addEventListener('click', async ()=>{
    if (roster.length === 0) {
      alert('No players in roster.');
      return;
    }
    if (!cameraSelect.value || !video.srcObject) {
      alert('Select a camera first.');
      return;
    }
    const buttonText = captureBtn.textContent;
    captureBtn.disabled = true; captureBtn.textContent = 'Processing…';
    try {
      const base = captureFrame(video, grid.canvasWidth, grid.canvasHeight);
      // Do OCR first; this may throw MANUAL_CANCELLED
      const placements = await processResultsScreen(base, roster, grid, { maxEditDistance: 3 });

      // Only if successful, make the snapshot and push the race
      const snapshotUrl = await snapshotBlobUrlFromCanvas(base);
      races.push({
        id: races.length + 1,
        timestamp: Date.now(),
        placements,
        snapshotUrl
      });

      if (races.length === 1) {
        lockIGNsFromPlacements(placements, roster);
      }

      renderResults(placements);
      renderScoreboard();
      renderRaceGallery();
    } catch (e) {
      // If the user canceled manual resolve, just abort quietly
      if (/** @type {any} */(e)?.code === 'MANUAL_CANCELLED') {
        console.log('Capture canceled by user.');
        return;
      }
      // Otherwise, surface the error
      console.error(e);
      alert('OCR failed. See console for details.');
    } finally { captureBtn.disabled = false; captureBtn.textContent = buttonText; }
  });

  /**
   * @param {Placement[]} placements
   */
  function renderResults(placements){
    outputOl.innerHTML = '';
    for (const r of placements){
      const li = document.createElement('li');

      const rank = document.createElement('span');
      rank.className = 'mono';
      rank.style.width = '2ch';
      rank.textContent = `${r.placement}.`;

      const name = document.createElement('span');
      name.style.flex = '1 1 auto';
      if (r.resolvedName) name.textContent = r.resolvedName;
      else {
        const em = document.createElement('em');
        em.className = 'muted';
        em.textContent = '(unresolved)';
        name.appendChild(em);
      }

      const ocr = document.createElement('span');
      ocr.className = 'muted mono';
      ocr.textContent = `OCR: “${r.ocrText}” · ${Math.round(r.ocrConfidence)}%`;

      li.append(rank, name, ocr);
      outputOl.appendChild(li);
    }
  }

  function renderScoreboard(){
    if (!scoreTable) return;
    const totals = computeTotals();
    // Order players by seed if available, else by name
    const ordered = [...roster].sort((a,b) => {
      const as = a.seed ?? 9999, bs = b.seed ?? 9999;
      if (as !== bs) return as - bs;
      return a.name.localeCompare(b.name);
    });

    // Build <thead>
    const thead = document.createElement('thead');
    const hr = document.createElement('tr');
    const hPlayer = document.createElement('th'); hPlayer.textContent = 'Player'; hr.appendChild(hPlayer);
    for (let i = 0; i < races.length; i++){
      const th = document.createElement('th'); th.textContent = `R${i+1}`; hr.appendChild(th);
    }
    const hTot = document.createElement('th'); hTot.textContent = 'Total'; hr.appendChild(hTot);
    thead.appendChild(hr);

    // Build <tbody>
    const tbody = document.createElement('tbody');

    for (const p of ordered){
      const tr = document.createElement('tr');

      const tdName = document.createElement('td'); tdName.textContent = p.name; tr.appendChild(tdName);

      // Each race: show placement number; use '—' if not present
      for (const r of races){
        const td = document.createElement('td');
        // find this player's placement in this race
        const row = r.placements.find(x => x.playerId === p.id);
        if (!row || row.dc === true || !normalizeName(row.ocrText)) td.textContent = '—';
        else {
          const ordinal = ['st','nd','rd'][row.placement-1] || 'th';
          td.textContent = `${row.placement}${ordinal}`;
        }
        tr.appendChild(td);
      }

      const tdTotal = document.createElement('td');
      tdTotal.textContent = String(totals[p.id] || 0);
      tr.appendChild(tdTotal);

      tbody.appendChild(tr);
    }

    // Build <tfoot> with Edit buttons per race column
    const tfoot = document.createElement('tfoot');
    const fr = document.createElement('tr');
    fr.appendChild(document.createElement('td')); // Commands...
    for (let i = 0; i < races.length; i++){
      const td = document.createElement('td');
      const btn = document.createElement('button');
      btn.textContent = 'Edit';
      btn.addEventListener('click', () => openEditRace(i));
      td.appendChild(btn);
      fr.appendChild(td);
    }
    const fEmpty = document.createElement('td'); fr.appendChild(fEmpty);
    tfoot.appendChild(fr);

    // Swap table content
    scoreTable.replaceChildren(thead, tbody, tfoot);
  }

  function renderRaceGallery(){
    if (!raceGallery) return;
    raceGallery.innerHTML = '';
    races.forEach((race, idx) => {
      const a = document.createElement('a');
      a.href = race.snapshotUrl; a.target = '_blank'; a.rel = 'noreferrer';
      const img = document.createElement('img');
      img.alt = `Race ${idx+1} snapshot`;
      img.src = race.snapshotUrl;
      const cap = document.createElement('div');
      cap.className = 'cap';
      const t = new Date(race.timestamp);
      cap.textContent = `Race ${idx+1} · ${t.toLocaleTimeString()}`;
      a.append(img, cap);
      raceGallery.appendChild(a);
    });
  }

  rosterDlg.showModal();
  listCameras();
  cameraSelect.addEventListener('change', startSelected);
  </script>
</body>
</html>
